"use strict";

const cellWhite = "#E9EDD6"; //"#FFFFB3";
const cellBlack = "#933D19"; //"black";

var myRule;
var myRun;
var myFrame;
var myCanvas;
var ruleNr = 30;	// 30 90 92 110

// Convert numeric rule to binary array (reversed: lower bits first)
const val2Array = value => {
	let arry = [];
	for (let i = 0; i < 8; i++) {
		arry.push(value & 1);
		value >>= 1;
	}
	return arry;
}

const draw = () => {
	const ruleArry = val2Array(ruleNr);

	// MyFrame is set to maximum size -- width:100%;height:100%
	let frameWidth = $("#myFrame").width();

	let canvasMidPoint = frameWidth >> 1;
	if ((frameWidth & 1) == 0) { // frameWidth is even
		canvasMidPoint--;
		frameWidth = (canvasMidPoint << 1) + 1; // make frameWidth odd
	}

	let canvasWidth = frameWidth;
	let canvasHeight = canvasMidPoint;

	// Set myCanvas to maximum size to display maximum iterations of rule 
	myCanvas.width = canvasWidth;
	myCanvas.height = canvasHeight;

	const canvasContext = myCanvas.getContext('2d');
	// Result set of ruleArry forms a triangle.
	// Pixels outside of triangle remain transparent.
	// Each cell corresponds to one pixel of canvas.

	// Pre-populate the triangle to cellWhite.
	canvasContext.fillStyle = cellWhite;

	canvasContext.beginPath();
	canvasContext.moveTo(canvasMidPoint, 0);	// mid-point top
	canvasContext.lineTo(1, canvasHeight - 1);	// left bottom
	canvasContext.lineTo(canvasWidth - 1, canvasHeight - 1);	// right botton
	canvasContext.fill();

	// Allocate and initialize containers for cell values.
	let currCells = new Array(canvasWidth).fill(0);
	let nextCells = new Array(canvasWidth).fill(0);

	// Now set pixels only when cell == 1 (true).
	// Set pixels within triangle according to values generated by ruleArry.
	canvasContext.fillStyle = cellBlack;

	// Generate first line.
	currCells[canvasMidPoint] = 1;
	canvasContext.fillRect(canvasMidPoint, 0, 1, 1);

	// Generate subsequent lines.
	// Each row
	// (nextCells) is derived by previous row
	// (currCells) using left,middle,right cells
	let cellIndexStart = canvasMidPoint - 1;
	let cellIndexEnd = canvasMidPoint + 1;
	for (let yCoord = 1; yCoord < canvasHeight; yCoord++) {

		let scope = [0, 0, 0];	// left cell, mid cell, right cell;
		for (let xCoord = cellIndexStart; xCoord <= cellIndexEnd; xCoord++) {

			[scope[0], scope[1], scope[2]] = [scope[1], scope[2], currCells[xCoord + 1]];
			// Shift the scope of cells i.e.
			// no need to calculate values for:
			// leftCell, midCell
			// since they are the same values of the previous iteration values:
			// midCell, rightCell

			let ruleArryIndex = scope[0];
			ruleArryIndex <<= 1;
			ruleArryIndex += scope[1];
			ruleArryIndex <<= 1;
			ruleArryIndex += scope[2];
			let cellValue = ruleArry[ruleArryIndex];
			if (cellValue == 1) {
				canvasContext.fillRect(xCoord, yCoord, 1, 1);
			}
			nextCells[xCoord] = cellValue;
		} // End xCoord

		// Switch pointers for the next iteration.
		[currCells, nextCells] = [nextCells, currCells];

		// Expand boundaries.
		cellIndexStart--;
		cellIndexEnd++;
	} // End yCoord
};

$(() => {
	myRule = $("#myRule");
	myRun = $("#myRun");
	myFrame = $("#myFrame");
	myCanvas = $("#myCanvas")[0];

	//myRule.change(e => {
	myRule.change(e => {
		e.preventDefault();

		let rule = parseInt(myRule.val().trim());
		if (rule > 0 && rule < 255) {
			myRule.text(rule);
			myRun.text(`Run Rule ${rule}`);
			ruleNr = rule;
		}
	});
	myRun.click(draw);
});